== Exploring Stackoverflow
:images: {img}

image::{img}/so_logo.svg[float=right,width=200px]

https://stackoverflow.com/[Stack Overflow^], the massively popular question-and-answer site for developers.

In this guide, you will learn:

* How you can model social data as graphs
* How to query the graph and answer questions using Cypher
* How to use shortest path algorithms to understand relationships

In the next section, you will import the Stack Overflow dataset into Neo4j.

== Stake Overflow Graph Model
[role=NX_TAB_NAV,tab=import]
pagelaunch::[]

The model contains data about users' questions, answers, and comments about Neo4j and Cypher.

Nodes represent: 

* `Users`
* `Questions`
* `Answers`
* `Comments`
* `Tags`.

image::{img}/model.svg[width=100%]

The relationships between these nodes show:

. What `User` `ASKED` a `Question`
. What `User` `PROVIDED` an `Answer`
. What `User` `COMMENTED` to a `Comment`
. What `Answer` `ANSWERED` a `Question`
. What `Comment` is `COMMENTED_ON` a `Question`
. What `Question` is `TAGGED` with a `Tag`

button::Import the StackOverflow dataset[role=NX_IMPORT_LOAD,endpoint=https://neo4j-graph-examples.github.io/stackoverflow/data/stackoverflow-data-importer.zip]

Click the highlight:import/import-run-import-button[Run import] button to import the data into Neo4j.

button::Explore the data model[role=NX_EXPLORE_SEARCH,search=User any Question any Answer]

Take a minute to _Explore_ the data model:

. Find a `Question` node
. Follow the `ASKED` relationship to the `User` who asked the question
. Find an `Answer` node and follow the `ANSWERED` relationship to the `Question` it answered

[TIP]
====
You can zoom in to see more detail and double-click on nodes to expand them and see their properties.
====

In the next section, you will use Cypher to query the graph.

== Users and Questions
[role=NX_TAB_NAV,tab=query]
pagelaunch::[]

Using the data model and Cypher, you can answer questions such as:

* Which users asked the most questions?
* Which users provided the most answers?
* How are users related to each other?
* Which questions are unanswered?
* What answers are the most popular?

The following query will use the `ASKED` relationship to find `User` and `Question` nodes.

.Match User and Question nodes
[source,cypher]
----
MATCH (u:User)-[a:ASKED]->(q:Question)
RETURN u,a,q
----

[NOTE]
====
The duplicate button icon:DuplicateIcon[] will copy the query to the clipboard.

The play button icon:PlayIcon[] will execute the query and return the results.
====

Run the query and observe the results. You should note that the `ASKED` relationship is in the direction `User` to `Question`.

[NOTE]
.Challenge
====
Can you complete this query to find `User` and `Answer` nodes using the `PROVIDED` relationship.

[source,cypher]
----
MATCH (u:User)-[ ]->( )
RETURN u,
----
====

The query will return this graph of `User` and `Answer` nodes.

image::{img}/user-provided-answer.png[A graph of User and Answer nodes. There are clear clusters of users and answers.]

The distribution of nodes in the graph is not uniform - you can see that a few users have provided many answers.

In the next section, you will write Cypher to discover who those users are.

== Exploring Users

As well as returning nodes, you can also return properties of nodes and aggregations (e.g. counts).

.How many questions did users ask?
[source,cypher]
----
MATCH (u:User)-[:ASKED]->(q:Question)
RETURN u.display_name, count(*) AS questions
----

Adding an order and limiting the number of rows will return a top 10 list of users who asked the most questions.

[source,cypher]
----
MATCH (u:User)-[:ASKED]->(q:Question)
RETURN u.display_name, count(*) AS questions
ORDER by questions DESC 
LIMIT 10
----

You can create a similar query for users who provided the most answers.

.How many answers did users provide?
[source,cypher]
----
MATCH (u:User)-[:PROVIDED]->(a:Answer)
RETURN u.display_name, COUNT(a) AS answers
ORDER BY answers DESC 
LIMIT 10
----

Users score answers on StakeOverflow. You can find each user's average score for answers using the `avg` function.

[source,cypher]
----
MATCH (u:User)-[:PROVIDED]->(a:Answer)
RETURN u.display_name, COUNT(a) AS answers, avg(a.score) as avg_score
ORDER BY answers DESC 
LIMIT 10
----

[NOTE]
.Challenge
====
Can you modify the query to find:

. The users with the highest average score by modifying the `ORDER`.
. The users with the highest maximum score by using the `max` function.
====

The graph also contains the comments that users make on questions. The `COMMENTED` relationship connects `User` and `Comment` nodes.

Complete this query to use the `COMMENTED` relationship to find the users who commented the most.

.Replace the `?`'s to complete the query
[source,cypher]
----
MATCH (u:User)-[:?????????]->(c:Comment)
RETURN u.display_name, COUNT(?) AS comments
ORDER BY ???????? DESC 
LIMIT 10
----

In the next section, you will use Cypher to filter the results returned by a query.

== Filtering Results

In the previous section, you used Cypher to find the users who asked the most questions and provided the most answers.

The user `"A. L"` asked the most questions, and `"cybersam"` provided the most answers.

You can filter the results using a filter on `MATCH` or by using a `WHERE` clause.

For example, find all the questions asked by `"A. L"`.

.Filter on MATCH
[source,cypher]
----
MATCH (u:User {display_name: "A. L"})-[a:ASKED]->(q:Question)
RETURN u,a,q
----

.Using a WHERE clause
[source,cypher]
----
MATCH (u:User)-[a:ASKED]->(q:Question)
WHERE u.display_name = "A. L"
RETURN u,a,q
----

Extending the query to include the `Tag` nodes through the `TAGGED` relationship allows you to filter for questions with a particular tag.

[source,cypher]
----
MATCH (u:User)-[a:ASKED]->(q:Question)-[tg:TAGGED]->(t:Tag)
WHERE u.display_name = "A. L" AND t.name = "cypher"
RETURN u,a,q,tg,t
----

[NOTE]
.Challenge
====
Can you find comments made by `"cybersam"` on questions tagged with `"neo4j"`? 

You will have to traverse the graph using the `User`, `Comment`, `Question`, and `Tag` nodes, through the `COMMENTED`, `COMMENTED_ON`, and `TAGGED` relationships.
====

In the next section, you will use shortest path functions to understand how users relate to each other.

== Shortest paths

As you have seen, users are related to each other through the questions they ask, the answers they provide, and the comments they make.

You can use shortest path functions to find the shortest path between users.

For example, you can use `shortestPath` function to find the shortest route between the user `"A. L"` who asked the most questions, and `"cybersam"` who provided the most answers.

[source,cypher]
----
MATCH path = shortestPath(
  (u1:User {display_name:"A. L"})-[*]-(u2:User {display_name:"cybersam"})
)
RETURN path;
----

The query is defined as the path `(u1:User {display_name:"A. L"})-[*]-(u2:User {display_name:"cybersam"})`.

The `[*]` is a wildcard that matches any relationship type.

The query returns the first shortest path it finds. You can return all of the shortest paths by using the `allShortestPaths` function.

[source,cypher]
----
MATCH path = allShortestPaths(
  (u1:User {display_name:"A. L"})-[*]-(u2:User {display_name:"cybersam"})
)
RETURN path;
----

[NOTE]
.Challenge
====
Can you identify 2 other users in the graph and find the shortest path between them?
====

In the next section, you will explore some Cypher queries and review the results.

== Exploring the Graph

In this section, you will review and run some Cypher queries which explore the graph.

Review each Cypher query before running and observing the results.

=== Unanswered Questions

What questions remain unanswered? In the graph, unanswered questions do not have an `ANSWERED` relationship.

The absence of a relationship is a valid path in Cypher. You can use the `NOT` keyword to negate a pattern.

[source,cypher]
----
MATCH (q:Question)
WHERE NOT (q)<-[:ANSWERED]-()
RETURN q
----

What type of questions relating to "neo4j" and "cypher" remain unanswered?

This query aggregates the results by the `Tag` node to show which tags have the most unanswered questions.

[source,cypher]
----
MATCH (q:Question)-[:TAGGED]->(t:Tag)
WHERE NOT t.name IN ['neo4j','cypher'] 
  AND NOT (q)<-[:ANSWERED]-()
RETURN t.name as tag, count(q) AS questions
ORDER BY questions DESC LIMIT 10;
----

=== User Engagement

By aggregating when users interacted with StakeOverflow, you can see how active they are.

For example, you can aggregate the number of questions answered by month.

[source,cypher]
----
MATCH (u:User)-[:PROVIDED]->()-[:ANSWERED]->
      (q:Question)-[:TAGGED]->(t:Tag)
WHERE u.display_name = "cybersam"
RETURN apoc.date.format(q.creation_date,'s','yyyy-MM') as month, 
       count(distinct q) as count, collect(distinct t.name) as tags
ORDER BY month asc
----

=== How are tags related to other tags?

Understanding how users tag questions can help you see patterns.

For example, how tags correlate to each other:

[source,cypher]
----
MATCH (t1:Tag)<-[:TAGGED]-()-[:TAGGED]->(t2:Tag)
WHERE id(t1) < id(t2) and t1.name <> 'neo4j' and t2.name <> 'neo4j'
RETURN t1.name, t2.name,count(*) as freq
ORDER BY freq desc LIMIT 10;
----

=== Virtual Graphs: Tags

Using virtual relationships can help you find unknown relationships in the graph. 

For example, you can create a virtual relationship between tags that occur together more than three times:

[source,cypher]
----
MATCH (t1:Tag)<-[:TAGGED]-()-[:TAGGED]->(t2:Tag)
WHERE id(t1) < id(t2) 
WITH t1, t2, count(*) as freq WHERE freq > 3
RETURN t1,t2, apoc.create.vRelationship(t1,'OCCURRED',{freq:freq},t2) AS rel
----

=== Virtual Graphs: Social Network

You can take a similar approach for _commenters_ - what users interact with each other in the comments? 

[source,cypher]
----
MATCH p1=(u1:User)-[:COMMENTED]->(c1:Comment)-[:COMMENTED_ON]-(q:Question)
MATCH p2=(u2:User)-[:COMMENTED]->(c2:Comment)-[:COMMENTED_ON]-(q)
WHERE id(u1) < id(u2)
WITH u1, u2, count(distinct q) as freq
WHERE freq > 2
RETURN u1, u2, apoc.create.vRelationship(u1,'OCCURRED',{freq:freq},u2) as rel
----

In the next section, you will find more resources to continue learning about Neo4j.

== Next steps

Congratulations on completing this guide!

You can continue your Neo4j learning journey with these resources:

* https://neo4j.com/graphacademy[Neo4j GraphAcademy - completely free online course^]
* https://neo4j.com/videos/exploring-stackoverflow-data-with-michael-hunger-twitch-stream/[Exploring StackOverflow data with Michael Hunger – Twitch stream^]
* https://neo4j.com/blog/import-10m-stack-overflow-questions/[Import 10M Stack Overflow Questionsinto Neo4j In Just 3 Minutes^]
